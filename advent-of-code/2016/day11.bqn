#!/usr/bin/env cbqn
âŸ¨For, MaxAtâŸ© â† â€¢Import "../lib.bqn"
numKinds â† 2
numStates â† 4â‹†1+2Ã—numKinds
# Element layout:
# - expanded (0/1)
# - cost (0<)
# - state index
MakeState â† {(<âŸ¨1, âˆ, Â¯1âŸ©) {âŸ¨1, âˆ, 1+2âŠ‘ğ•¨âŸ©}` ğ•©}(â†•(4âŠ¸â‹†(1âŠ¸+(2âŠ¸Ã—))))
states â† MakeState numKinds
# â€¢Show states
# â€¢Show "states"
start â† 0
ToIndex â† (+âŸœ(4âŠ¸Ã—))Â´âŒ½
ToState â† {
    (Â¯1+Â¯2Ã—numKinds)â†‘ {
        F 0: âŸ¨0âŸ©;
        F n: {(F (n-ğ•©)Ã·4)âˆ¾ğ•©} 4|n
    } ğ•©
}

# Return 1 if ğ•© is safe for all microtips
IsSafe â† { 
         F state: âŒŠÂ´ stateâŠ¸(FËœ)Â¨ â†•numKinds;
    kind F state:
        floor â† (2+2Ã—kind)âŠ‘state
        generator â† 1+2Ã—kind
        # â€¢Show âŸ¨"kind", kind, state, (floor=generatorâŠ‘state) âˆ¨ (âˆ§Â´ {floor â‰  ğ•©âŠ‘state}Â¨ 1+2Ã—â†•numKinds)âŸ©
        (floor=generatorâŠ‘state) âˆ¨ (âˆ§Â´ {floor â‰  ğ•©âŠ‘state}Â¨ 1+2Ã—â†•numKinds)
}
IsGoal â† { F state: âˆ§Â´ {3=ğ•©âŠ‘state}Â¨ 1+2Ã—â†•numKinds }
# Returns the set of objects which you can move with elevator from the current floor.
NextObjectsStates â† { F state:
    Mask â† {
        (Â¯2Ã—numKinds)â†‘ {
            F 0: âŸ¨0âŸ©;
            F n: {(F (n-ğ•©)Ã·2)âˆ¾ğ•©} 2|n
        } ğ•©
    }
    objects â† {(âŠ‘ğ•©)âŠ¸=Â¨ 1â†“ğ•©} state
    # â€¢Show (objectsÃ—Mask)Â¨ â†•2â‹†2Ã—numKinds
    # â€¢Show â·(âŒˆÂ´objectsÃ—Mask)Â¨ â†•2â‹†2Ã—numKinds
    ({âŒˆÂ´ğ•© âˆ§ objects=ğ•©}Â¨)âŠ¸/â·(objectsÃ—Mask)Â¨ â†•2â‹†2Ã—numKinds
}

# Returns the set of valid and safe states transited from the current state.
NextStates â† { F state:
    elevator â† âŠ‘state
    objects â† 1â†“state
    w â† NextObjectsStates state
    nextFloors â† elevatorâŠ¸â‰ Â¨âŠ¸/ â†•4
    # â€¢Show â¥Š nextFloors {ğ•¨âˆ¾ ğ•¨Ã—ğ•©}âŒœ w
    cands â† â¥Š nextFloors {ğ•¨âˆ¾ ((Â¬ğ•©)Ã—objects) + ğ•¨Ã—ğ•©}âŒœ w
    â€¢Show IsSafeÂ¨ cands
    results â† IsSafeÂ¨âŠ¸/ cands
    â€¢Show âŸ¨>â‰ cands, " => ", >â‰ resultsâŸ©
    results
}

# Loop until reaching the goal
Seek â† { F init:
    ii â† ToIndex init
    {
        IsGoal init ? âŠ‘iiâŠ‘states;
        cost â† âŠ‘init
        nexts â† NextStates init
        â€¢Show â‰  nexts
        (1â€¿costâ€¿ii)Ë™âŒ¾(iiâŠ¸âŠ‘) states
        cost+â†© 1
        {
            state â† ğ•©
            i â† ToIndex state
            â€¢Show âŸ¨"update: ", i, 1âŠ‘iâŠ‘statesâŸ©
            cost < 1âŠ‘iâŠ‘states ? states â†© (0â€¿costâ€¿i)Ë™âŒ¾(iâŠ¸âŠ‘) states; @
        }Â¨ nexts
        â€¢Show "eee"
        â€¢Show {0=âŠ‘ğ•©}Â¨âŠ¸/states
        next â† 2âŠ¸âŠ‘ 1âŠ¸MaxAt {0=âŠ‘ğ•©}Â¨âŠ¸/states
        F next
    }
}
# Part 1 Description: #####################################
# - 0: a hydrogen M, a lithium M.
# - 1: a hydrogen G.
# - 2: a lithium G.
# - 3: nothing relevant.
# Encode: hydrogen, lithium
# naive coding:
#     0â€¿0â€¿0â€¿0â€¿0
#     0â€¿0â€¿0â€¿1â€¿0
#     0â€¿1â€¿0â€¿0â€¿0
#     1â€¿0â€¿1â€¿0â€¿1
# flagâ€¿costâ€¿status for Dijkstra(plae the position of elevator at first): 0â€¿0â€¿0â€¿1â€¿0â€¿2â€¿0
# For Dijkstra: flagâ€¿cost[0Ã—256+1Ã—64+0Ã—16+2Ã—4+0Ã—1=72] = 1â€¿0
numKinds â†© 2
states â†© MakeState numKinds
start_state â† âŸ¨0, 1, 0, 2, 0âŸ©
â€¢Show (<"IsSafe")âˆ¾IsSafe start_state
start â†© ToIndex start_state
â€¢Show { (ToState ğ•©)â€¿ğ•©â€¿(ToIndex ToState ğ•©) } start
"Fail to build the 1-arrow" ! (ToStateâˆ˜ToIndex)âŠ¸(âˆ§Â´=) start_state
# â€¢Show NextStates ToState start
â€¢Show Seek start_state
# Part 1: #####################################
# - 0: a strontium G, a strontium M, a plutonium G, a plutonium M.
# - 1: a thulium G, a ruthenium G, a ruthenium M, a curium G, a curium M.
# - 2: a thulium M.
# - 3: nothing relevant.
# Encode: strontium, plutonium, thulium, ruthenium, curium
numKinds â†© 5
states â†© MakeState numKinds
start â†© ToIndex âŸ¨0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 1âŸ©
# Part 2: #####################################
