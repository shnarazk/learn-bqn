#!/usr/bin/env cbqn
âŸ¨Max, MinAt, WhileâŸ© â† â€¢Import "../lib.bqn"
toCheck â† âŸ¨âŸ©
checked â† âŸ¨âŸ©
numKinds â† 1
ToIndex â† (+âŸœ(4âŠ¸Ã—))Â´âŒ½
ToState â† {
    (Â¯1+Â¯2Ã—numKinds)â†‘ {
        F 0: âŸ¨0âŸ©;
        F n: {(F (n-ğ•©)Ã·4)âˆ¾ğ•©} 4|n
    } ğ•©
}
# Return 1 if ğ•© is safe for all microchips
IsSafe â† { 
         F state: âŒŠÂ´ stateâŠ¸(FËœ)Â¨ â†•numKinds;
    kind F state:
        floor â† (2+2Ã—kind)âŠ‘state
        generator â† 1+2Ã—kind
        (floor=generatorâŠ‘state) âˆ¨ (âˆ§Â´ {floor â‰  ğ•©âŠ‘state}Â¨ 1+2Ã—â†•numKinds)
}
# Returns the set of objects which you can move with elevator from the current floor.
NextObjectsStates â† { F state:
    Mask â† {
        (Â¯2Ã—numKinds)â†‘ {
            F 0: âŸ¨0âŸ©;
            F n: {(F (n-ğ•©)Ã·2)âˆ¾ğ•©} 2|n
        } ğ•©
    }
    objects â† {(âŠ‘ğ•©)âŠ¸=Â¨ 1â†“ğ•©} state
    blank â† 0Ë™Â¨1â†“state
    indexes â† objects/ âŠ¢Ã—âŸœ(â†•âˆ˜â‰ ) objects
    cands â† âŸ¨âŸ©
    { F i:
        cand â† 1Ë™âŒ¾(iâŠ¸âŠ‘) blank
        { F j: iâ‰¤j ? candsâˆ¾â†© <1Ë™âŒ¾(jâŠ¸âŠ‘)cand; @ }Â¨ indexes
    }Â¨ indexes
    cands
}
# Returns the set of valid and safe states transited from the current state.
NextStates â† { F state:
    elevator â† âŠ‘state
    objects â† 1â†“state
    nextFloors â† {(0â‰¤ğ•©)âˆ§(ğ•©<4)}Â¨âŠ¸/âŸ¨Â¯1+elevator, 1+elevatorâŸ©
    cands â† â¥Š nextFloors {ğ•¨âˆ¾ ((Â¬ğ•©)Ã—objects) + ğ•¨Ã—ğ•©}âŒœ NextObjectsStates state
    IsSafeÂ¨âŠ¸/ cands
}
Estimate â† { F state:
    cs â† 2âŠ¸|Â¨ â‰ state
    gs â† Â¬Â¨ cs
    dist â† 3-Â¨ state
    (2Ã—+Â´1â†“csÃ—dist) + +Â´1â†“gsÃ—dist
}

HashTableNew â† {
  htâ†âŸ¨âŸ©Ë™Â¨â†•4â‹†1+ğ•©
  maskâ†Â¬2âŠ¸|Â¨â†•1+2Ã—ğ•©
  Keyâ‡{0 {ğ•¨+4Ã—ğ•©}Â´ mask/ToState ğ•©}
  Addâ‡{ F ğ•©: k â† Key ğ•© â‹„ htâ†© (ğ•©âŠ¸âˆ¾)âŒ¾(kâŠ¸âŠ‘) ht}
  Contains â‡{F ğ•©: k â† Key ğ•© â‹„ âŠ‘ğ•©âˆŠkâŠ‘ht}
  # Len â‡{ğ•¤â‹„ â‰ ht}
  # Dbg â‡{mask/ğ•©}
}
Seek â† { F init:
    numKinds â†© 2Ã·ËœÂ¯1+â‰ init
    goal â† Â¯1+4â‹†â‰ init
    toCheck â† âŸ¨âŸ¨0, 0, ToIndex initâŸ©âŸ©
    checked â† HashTableNew numKinds
    SeekStep â† { F âŸ¨est, cost, iiâŸ©:
        {
            i â† ToIndex ğ•©
            # (Â¬checked.Contains i) âˆ§ (âŸ¨iâŸ© Â¬âˆ˜âŠ‘âˆ˜âˆŠ ((2âŠ¸âŠ‘)Â¨ toCheck)) ?
            Â¬checked.Contains i ?
                toCheck âˆ¾â†© âŸ¨âŸ¨cost+Estimate ğ•©, cost+1, iâŸ©âŸ© ; @
        }Â¨ NextStates ToState ii
    }
    next â† âŸ¨âŸ©
    ğ•¤â‹„ While {ğ•¤â‹„ Â¬checked.Contains goal}â€¿{
        ğ•¤
        next â† âŠ‘toCheck
        toCheck â†© 1â†“toCheck
        index â† 2âŠ‘next
        {
            goal = index ?
                checked.Add index
                â€¢Show âŸ¨"result", 1âŠ‘nextâŸ©
            ;
            Â¬checked.Contains index ?
                checked.Add index
                SeekStep next
                toCheck â†© âˆ§ toCheck
            ; @
        }
    }
}
# Part 1 Description: #####################################
# - 0: a hydrogen M, a lithium M.
# - 1: a hydrogen G.
# - 2: a lithium G.
# - 3: nothing relevant.
# Encode: hydrogen, lithium
# naive coding:
#     0â€¿0â€¿0â€¿0â€¿0
#     0â€¿0â€¿0â€¿1â€¿0
#     0â€¿1â€¿0â€¿0â€¿0
#     1â€¿0â€¿1â€¿0â€¿1
# Seek âŸ¨0, 1, 0, 2, 0âŸ©
# Part 1: #####################################
# - 0: a strontium G, a strontium M, a plutonium G, a plutonium M.
# - 1: a thulium G, a ruthenium G, a ruthenium M, a curium G, a curium M.
# - 2: a thulium M.
# - 3: nothing relevant.
# Encode: strontium, plutonium, thulium, ruthenium, curium
Seek âŸ¨0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 1âŸ©
# Part 2: #####################################
# Seek âŸ¨0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0âŸ©
